---
layout: post
title:  "Data engineering unit tests"
date:   2020-07-24
categories: data engineering
---

My nephew is obsessed with board games. He especially likes Jenga, the game where each player must remove a block from a tower and replace the block at the top of the tower. His favorite part of the game is the very end, when the tower of blocks comes crashing down to the ground. Perhaps this is simply a reflection on the number of hours I have spent playing Jenga and writing code, but I think that engineering teams face similar challenges as the players around a Jenga table.

One of the greatest challenges for a maturing engineering team is to continue building, without breaking what has already been built. Architects need to make sure that a new addition to a building will not collapse the existing structure. Software engineers need to verify to that a new piece of code will not disrupt the existing code set. And data engineers need to verify that additions, or changes, to one part of the data product do not disturb the rest of the data product.

Let's consider the following hypothetical. Crazy Car Insurance is a car insurance company which offers insurance to rental car agencies. Within Crazy Car Insurance, there is a data engineering team which aggregates data from the rental car companies. They have some SQL code to transform their input data into a core data model.

### <center> Core Data Model </center>
```
t_customerexpenses
t_customerrevenue
t_customeraccidents
t_customerrepairs
```

One day, the data engineering team decides to change how a column is calculated in `t_customerexpenses`. They are successful with their change to `t_customerexpenses`, but then they realize that `t_customeraccidents` is created from `t_customerexpenses`, and their change actually affected a column in `t_customeraccidents`. If the team is small enough, the developer who is making the change will realize the relationship between all the tables and anticipate how his change will affect all the tables in the data model.

There are numerous problems with this approach.

1. What is the data model is complex, and the developer understandably does not have its architecture committed to memory?
2. What about new team members who didn't build the data model? How do they contribute?

**We can do better.** What if we built an automated system to alert us when any changes were made to the data model? One way of unit testing is to compare tables before and after a code modification, and to observe any change in the tables. It turns out, there is a rather simple way to do this in SQL. We can convert each value in the table into a unique integer, and combine all the integers in a combinatorially unique way which ultimately yields a single number to represent the state of the table. This is the concept of checksums.


In T-SQL, table checksums can be calculated using the following query. Note that there will be some [collisions](https://en.wikipedia.org/wiki/Collision_(computer_science)) - there will be some instances where a value changes in the table but the checksum remains the same. The percentage of collisions should be quite low (<1%).

{% highlight sql %}
SELECT 		CHECKSUM_AGG(CHECKSUM(*))
FROM 		database.dbo.table
{% endhighlight %}


Returning to our example, the developers can use the table checksums to identify any changes in the data model. They could run the checksums on each table before the code modification, and after the code modification, and compare the two sets of checksums. The difference between the two will indicate if the table changed in any way.

| Table | Checksum 1 | Checksum 2 | Difference | Unit Test |
| -- | -- | -- | -- | -- |
| t_customerexpenses | -2865217 | 9319512 | 12184729 | FAIL |
| t_customerrevenue | -8678565 | -8678565 | 0 | PASS |
| t_customeraccidents | -5280160 | -6094035 | -813875 | FAIL |
| t_customerrepairs | 3268048 | 3268048 | 0 | PASS |

This method will ensure that changes to one table do not affect the other tables in the data model. Further exploring this concept, we could perform unit tests on pieces of an individual table. For example, if we change the code for one customer in `t_customerexpenses`, we could write a unit test to verify that the data for the rest of the customers remains unchanged.